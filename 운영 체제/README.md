# 운영 체제 (Operating System, OS)

운영 체제는 **컴퓨터 하드웨어 바로 위에 설치된 소프트웨어 계층**으로, 사용자 및 다양한 소프트웨어와 하드웨어 간의 **중재자 역할**을 합니다. 하드웨어를 직접 관리하며 다른 소프트웨어들과 구별되는 핵심 기능을 수행합니다.

```
사용자 / 각종 소프트웨어
          ↓
       운영 체제
          ↓
     컴퓨터 하드웨어
```

---

## 운영 체제의 목적

### 1. 사용자에게 편리한 환경 제공
- 여러 사용자와 프로그램이 **각각 독립적인 컴퓨터를 사용하는 듯한 환상** 제공
- 하드웨어 제어의 **복잡성을 OS가 대신 처리**

### 2. 시스템 자원의 효율적 관리
- **CPU, 메모리, I/O 장치 등** 자원을 효율적으로 분배
  - **효율성**: 주어진 자원으로 최고의 성능
  - **형평성**: 특정 사용자/프로그램이 과도한 불이익을 받지 않도록 조정
- 사용자 및 OS의 자원 보호

### 3. 자원 공유 (Resource Sharing)
- 실행 중인 프로그램에 짧은 시간씩 **CPU 할당**
- 프로그램에 **메모리 공간 적절히 분배**

---

## 컴퓨터 시스템 구성

- **CPU - 메모리 (내부)**
- **I/O 디바이스 (디스크, 키보드, 모니터, 프린터 등)**  
  → I/O 장치는 **I/O 컨트롤러**를 통해 CPU와 통신

---

## CPU 스케줄링

### 어떤 프로그램에 CPU 사용권을 줄 것인가?

#### 1. FCFS (First Come First Served)
- **들어온 순서**대로 CPU를 할당

#### 2. SJF (Shortest Job First)
- **가장 짧은 작업**을 먼저 실행
- **최소 평균 대기시간** 보장
- 단점: **기아 현상 (Starvation)** 가능 → 긴 작업이 계속 밀림

#### 3. Round Robin
- **고정된 시간 할당량(Time Quantum)**으로 CPU를 나눔
- 시간이 끝나면 **인터럽트 발생**, 프로세스는 **큐 뒤로 이동**
- **형평성**이 뛰어남
- N개의 프로세스가 있을 때, 어떤 프로세스도 **(N-1) × 시간 할당량 이상 기다리지 않음**

---

## 디스크 스케줄링 (Disk Scheduling)

디스크 스케줄링은 **디스크 I/O 요청을 어떤 순서로 처리할 것인가**를 결정하는 기법입니다.  
**헤드의 이동을 최소화**하여 **seek time**을 줄이는 것이 목표입니다.

### 디스크 접근 시간 (Access Time)의 구성

1. **탐색 시간 (Seek Time)**  
   - 헤드를 해당 트랙(실린더)으로 이동시키는 데 걸리는 시간  
   - **seek time ≒ 헤드의 이동 거리(seek distance)**

2. **회전 지연 (Rotational Latency)**  
   - 헤드가 원하는 섹터에 도달하기까지 디스크가 회전하는 데 걸리는 시간

3. **전송 시간 (Transfer Time)**  
   - 실제 데이터를 전송하는 데 걸리는 시간

### 디스크 스케줄링 알고리즘

#### 1. FCFS (First Come First Served)
- 큐에 **들어온 순서대로** 디스크 요청을 처리
- 구현이 간단하지만, **헤드 이동이 많아질 수 있음**

#### 2. SSTF (Shortest Seek Time First)
- 현재 헤드 위치에서 **가장 가까운 요청**을 먼저 처리
- 평균 성능은 FCFS보다 좋지만,  
  **기아 현상 (Starvation)** 발생 가능  
  → 멀리 있는 요청은 계속 밀릴 수 있음

#### 3. SCAN
- **엘리베이터 스케줄링**이라고도 불림
- 헤드가 **한쪽 끝으로 이동하며** 지나가는 요청들을 처리
- 끝에 도달하면 **방향을 바꿔서** 다시 오는 길에 요청들을 처리
- → 마치 엘리베이터가 올라갔다 내려오듯 동작

> **특징**:  
> - 정해진 방향으로 요청을 처리하기 때문에 예측 가능하고 기아 현상이 적음  
> - 평균적인 성능도 우수

---

## 메모리 관리

### 메모리와 저장장치 간 관계
- **메모리**는 CPU의 작업 공간
- **디스크 → 가상 메모리 → 실제 메모리**로 데이터 이동
- 메모리에 데이터가 없을 경우, **스왑 영역(디스크)**을 사용

### 가상 메모리와 페이지 교체

- 프로그램은 여러 개의 **페이지**로 나뉨
- 어떤 페이지를 메모리에서 **쫓아낼 것인가?**가 중요

#### 대표적인 페이지 교체 알고리즘

- **LRU (Least Recently Used)**  
  → 가장 오래 전에 참조된 페이지 삭제

- **LFU (Least Frequently Used)**  
  → 참조 횟수가 가장 적은 페이지 삭제

> 과거의 데이터를 바탕으로 미래를 예측하지만, 완벽하지는 않음  
> (예: 과거에 인기 있었다고 미래에도 인기 있을까? / 최근에 썼다고 계속 쓸까?)

---

## 저장장치 계층 구조와 캐싱 (Storage Hierarchy & Caching)

컴퓨터의 저장장치는 **속도, 용량, 가격**에 따라 여러 계층으로 나뉘며,  
이러한 계층 구조를 통해 **속도 차이를 완충**하고 **성능과 비용의 균형**을 맞춥니다.

```
Registers
↑↓
Cache Memory
↑↓
Main Memory(DRAM)
↑↓
------------------ 휘발성, Primary(Executable) - CPU가 직접 제어하는 컴퓨터 내부
------------------ 비휘발성, Secondary - CPU가 접근 불가한 I/O 장치
↑↓
Magnetic Disk
↑↓
Optical Disk
↑↓
Magentic Tape
```

위로 올라갈수록:
- **속도 빠름**
- **용량 작음**
- **가격 비쌈**

### 캐싱 (Caching)

- **상위 계층의 속도 차이를 완충**하기 위해 도입
- **하위 계층의 데이터 복사본**을 **상위 계층에 저장**
- 자주 쓰는 데이터는 상위 계층에 두고 빠르게 접근

---

## 플래시 메모리 (Flash Memory)

플래시 메모리는 **반도체 기반 저장장치**로,  
기존의 **하드디스크(자기 디스크)**와는 달리 **전자 회로로 데이터 저장**이 이루어집니다.

---

### 플래시 메모리의 종류

- **NAND형**  
  - 대용량 **스토리지 저장용**  
  - 예: USB, SSD, 메모리 카드 등

- **NOR형**  
  - **임베디드 시스템의 코드 저장용**  
  - 빠른 읽기 속도, 직접 실행(XIP) 가능

### 주요 특징

- **비휘발성 (Non-volatile)**  
  → 전원이 꺼져도 데이터 유지

- **저전력 소비 (Low Power Consumption)**

- **충격 저항성 (Shock Resistance)**  
  → 물리적 충격에 강함

- **소형 (Small Size), 경량 (Lightweight)**

- **쓰기 횟수 제한**  
  → 셀의 수명이 정해져 있음 (특정 횟수 이상 쓰면 성능 저하)

- **데이터 훼손 가능성**  
  → **전하량**으로 0과 1을 구분하는 방식이기 때문에,  
     시간이 지남에 따라 **전하가 누설되어 데이터 손상 가능성** 존재

### 사용 형태

- **임베디드 시스템용**:  
  - 휴대폰, PDA 등 소형 전자기기

- **이동식 저장장치**:  
  - USB 메모리 스틱

- **디지털 기기용**:  
  - SD 카드, CompactFlash, Smart Media Card 등

- **대용량 스토리지용**:  
  - SSD (Solid State Drive) 형태로  
    하드디스크(HDD)를 **대체**하려는 시도

---

> 플래시 메모리는 고속, 소형, 저전력 등의 장점을 바탕으로  
> **모바일 장치부터 서버/데이터센터까지** 광범위하게 사용되고 있습니다.

## 기타 핵심 개념

- **인터럽트**: I/O 컨트롤러가 작업 완료를 **CPU에 알리는 신호**
- **캐싱**: 빠른 CPU와 느린 장치 간의 **속도 차이 극복**을 위한 기술

---

## 애플리케이션 유형

- **Interactive Application**: 사용자와 **I/O 중심** 상호작용
- **Scientific Application**: **CPU 중심** 연산 집중형

